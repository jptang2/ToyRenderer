#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"
#include "common.glsl"

#define THREAD_SIZE_X 16	
#define THREAD_SIZE_Y 16	
#define THREAD_SIZE_Z 1	
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main() 
{
	// 第三轮 计算屏幕空间效果
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	if(pixel.x >= WINDOW_WIDTH || pixel.y >= WINDOW_HEIGHT ) return;

	vec2 inUV = pixel.xy / vec2(WINDOW_WIDTH, WINDOW_HEIGHT);
	
	// 本帧抖动////////////////////////////////////////////////////////////////////////////////////
	Rand rand = SeedRand(GLOBAL_SETTING.totalTicks, (pixel.y + WINDOW_HEIGHT) * GLOBAL_SETTING.totalTicks + (pixel.x + WINDOW_WIDTH));
	vec2 ditter = vec2(RandFloat(rand), RandFloat(rand));
	ditter = (ditter - 0.5) / vec2(VOLUMETRIC_FOG_SIZE_X, VOLUMETRIC_FOG_SIZE_Y); 

	// 坐标////////////////////////////////////////////////////////////////////////////////////

	vec4 worldPos = DepthToWorld(inUV); //本帧的世界空间坐标，根据深度获取

	//随机抖动一下，如果深度差距不大就可以直接用邻近的，差距太大的话抖动会导致边缘噪声很大  	
	if(abs(	LinearEyeDepth(FetchDepth(inUV), 			CAMERA.near, CAMERA.far) - 
			LinearEyeDepth(FetchDepth(inUV + ditter), 	CAMERA.near, CAMERA.far)) < 1.0)	 worldPos = DepthToWorld(inUV + ditter);      
			 	

    vec4 viewPos     		= WorldToView(worldPos);      
    vec4 ndcPos      		= ViewToNDC(viewPos);
	ndcPos.xy 				= min(ndcPos.xy, 0.99);	//边缘有点小问题
                                   
    ivec3 clusterID 	= FetchVolumetricClusterID(ndcPos.xyz);
	clusterID = ivec3(clusterID.xy, max(clusterID.z, 0));

    vec4 data           = imageLoad(VOLUMETRIC_FOG_INTEGRAL, clusterID);
	float weight = data.w;
    if(FetchDepth(inUV) == 1.0)    weight = 1.0;   //天光不衰减
    vec4 outColor  	 	= vec4(data.xyz + imageLoad(VOLUMETRIC_FOG_IMG, pixel.xy).xyz * weight, 1.0f);   //混合，输出，屏幕光照要乘以穿透率混合 

	if(SETTING.fogOnly != 0) outColor = vec4(data.xyz, 1.0f);

	// vec4 outColor = vec4(vec3(clusterID) / vec3(VOLUMETRIC_FOG_SIZE_X, VOLUMETRIC_FOG_SIZE_Y, VOLUMETRIC_FOG_SIZE_Z), 1.0f);

	imageStore(VOLUMETRIC_FOG_IMG, ivec2(pixel.xy), outColor);

}



