#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"
#include "include/common.glsl"

#define THREAD_SIZE_X 16
#define THREAD_SIZE_Y 16
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main() 
{
    ivec2 pixel     = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv         = ScreenPixToUV(pixel); 

   	vec4 gbffer0    = imageLoad(G_BUFFER_DIFFUSE_ROUGHNESS, pixel);
    vec4 gbffer1    = imageLoad(G_BUFFER_NORMAL_METALLIC, pixel);
    vec4 gbffer2    = imageLoad(G_BUFFER_EMISSION, pixel);
    vec3 diffuse    = gbffer0.xyz;
    vec3 normal     = normalize(gbffer1.xyz);
    vec3 emission   = gbffer2.xyz;
    float roughness = gbffer0.w;
    float metallic  = gbffer1.w;
    vec4 worldPos   = DepthToWorld(uv); 
	float depth 	= FetchDepthTex(pixel);

	// 空域复用Reservoir //////////////////////////////////

	uint reservoirIndex = ReservoirIndex(pixel);
	Reservoir res = RESERVOIRS[reservoirIndex];
	Rand rand = SeedRand(GLOBAL_SETTING.totalTicks, pixel.y * GLOBAL_SETTING.totalTicks + pixel.x);

	ivec2 neighborPixel[NUM_NEIGHBORS];
	vec3 neighborNormal[NUM_NEIGHBORS];
	uint neighborNumStreamSamples[NUM_NEIGHBORS];
	uint originNumStreamSamples = res.numStreamSamples;

	if(depth < 1.0f && RESTIR_SETTING.spatialReuse != 0)
	{
		for(int j = 0; j < NUM_NEIGHBORS; j++)
		{	
			float angle = RandFloat(rand) * 2.0 * PI;								// 搜索圆范围内的随机临近像素
			float radius = sqrt(RandFloat(rand)) * RESTIR_SETTING.spatialRadius;

			ivec2 randNeighborOffset = ivec2(floor(cos(angle) * radius), floor(sin(angle) * radius));
			ivec2 randNeighborPixel  = ivec2(clamp(int(pixel.x) + randNeighborOffset.x, 0, int(WINDOW_WIDTH) - 1),
											 clamp(int(pixel.y) + randNeighborOffset.y, 0, int(WINDOW_HEIGHT) - 1));
			vec2 randNeighborUV = ScreenPixToUV(randNeighborPixel);
			uint randIndex 		= ReservoirIndex(randNeighborPixel);	
			
			neighborPixel[j] = randNeighborPixel;
			neighborNumStreamSamples[j] = RESERVOIRS[randIndex].numStreamSamples; 
			neighborNormal[j] = normalize(imageLoad(G_BUFFER_NORMAL_METALLIC, randNeighborPixel).xyz);

			float neighborDepth = FetchDepthTex(randNeighborPixel);
			if(neighborDepth == 1.0f) 
			{
				neighborNumStreamSamples[j] = 0;
				continue;
			}

			//if(RESTIR_SETTING.unbias == 0)	// 可以简单筛一下临近像素，原论文只在有偏时使用
			{
				vec3 positionDiff = worldPos.xyz - DepthToWorld(randNeighborUV).xyz;
				float normalDot = dot(normal, neighborNormal[j]);
				if (length(positionDiff) > RESTIR_SETTING.spatialPosThreshold  ||			// 弃置世界距离差异大的，原论文比较的是深度
					normalDot < cos(radians(RESTIR_SETTING.spatialNormalThreshold)))		// 弃置法线差异大的
				{
					neighborNumStreamSamples[j] = 0;
					continue;
				}
			}

			Reservoir randRes = RESERVOIRS[randIndex];
			float pHat[RESERVOIR_SIZE];
			for (int i = 0; i < RESERVOIR_SIZE; ++i) 
			{
				float newPHat = EvaluatePHat(
					randRes.samples[i].lightID, worldPos.xyz, normal,
					diffuse, roughness, metallic); 

				pHat[i] = newPHat;
			}
			CombineReservoirs(res, randRes, pHat, rand);
		}

		if(RESTIR_SETTING.unbias != 0)
		{
			for (int i = 0; i < RESERVOIR_SIZE; i++) 
			{
				uint z = originNumStreamSamples;
				for(int j = 0; j < NUM_NEIGHBORS; j++)
				{		
					// 需要重新评估该采样光源对于临近像素是否有贡献，来更新权重
					// 也没必要再算一遍phat，确定0项就行

					// vec4 neighborGbffer0    = imageLoad(G_BUFFER_DIFFUSE_ROUGHNESS, neighborPixel[j]);
					// vec4 neighborGbffer1    = imageLoad(G_BUFFER_NORMAL_METALLIC, neighborPixel[j]);
					// vec4 neighborGbffer2    = imageLoad(G_BUFFER_EMISSION, neighborPixel[j]);
					// vec3 neighborDiffuse    = neighborGbffer0.xyz;
					// vec3 neighborNormal     = normalize(neighborGbffer1.xyz);
					// vec3 neighborEmission   = neighborGbffer2.xyz;
					// float neighborRoughness = neighborGbffer0.w;
					// float neighborMetallic  = neighborGbffer1.w;
					vec4 neighborWorldPos   = DepthToWorld(ScreenPixToUV(neighborPixel[j])); 

					// float newPHatNeighbor = EvaluatePHat(		
					// 	res.samples[i].lightID, neighborWorldPos.xyz, neighborNormal,
					// 	neighborDiffuse, neighborRoughness, neighborMetallic);
					// if(newPHatNeighbor <= 0.0) continue;

					PointLight pointLight 	= LIGHTS.pointLights[res.samples[i].lightID];
					float neighborDistance 	= length(neighborWorldPos.xyz - pointLight.pos);
					vec3 neighborL		 	= normalize(pointLight.pos - neighborWorldPos.xyz);
					vec3 neighborN 			= normalize(neighborNormal[j]);
					if(dot(neighborN, neighborL) <= 0.0f || neighborDistance >= pointLight.far)	continue;


					if(RESTIR_SETTING.visibilityReuse != 0)		// 可见性测试是最主要的性能开销
					{
						bool shadowed = RayQueryVisibility(neighborWorldPos.xyz, LIGHTS.pointLights[res.samples[i].lightID].pos);
						if(shadowed) continue;
					}
							
					z = z + neighborNumStreamSamples[j]; 				
				}

				if(RESTIR_SETTING.visibilityReuse != 0)
				{
					bool shadowed = RayQueryVisibility(worldPos.xyz, LIGHTS.pointLights[res.samples[i].lightID].pos);
					if(shadowed) 
					{
						CleanReservoir(res, i);			
					}
				}
				
				if (z > 0 && res.samples[i].pHat > 0.0) 
				{
					res.samples[i].w = (1.0 / res.samples[i].pHat) * (1.0 / z) * res.samples[i].sumWeights;	// 无偏就是这两行的区别
					//res.samples[i].w = (1.0 / res.samples[i].pHat) * (1.0 / res.numStreamSamples) * res.samples[i].sumWeights;	
					// 由于错误的考虑了pHat为0的采样，有偏的实际上会偏暗
				}
				else {
					CleanReservoir(res, i);			
				}
			}
		}
	}

	RESULT_RESERVOIRS[reservoirIndex] = res;
}
