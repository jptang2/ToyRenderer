#version 460
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"	
#include "include/common.glsl"	

#define THREAD_SIZE_X 16
#define THREAD_SIZE_Y 16
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main()
{
    ivec2 pixel     = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv         = ScreenPixToUV(pixel); 

    vec4 gbffer0    = imageLoad(G_BUFFER_DIFFUSE_ROUGHNESS, pixel);
    vec4 gbffer1    = imageLoad(G_BUFFER_NORMAL_METALLIC, pixel);
    vec4 gbffer2    = imageLoad(G_BUFFER_EMISSION, pixel);
    vec3 diffuse    = gbffer0.xyz;
    vec3 normal     = gbffer1.xyz;
    vec3 emission   = gbffer2.xyz;
    float roughness = gbffer0.w;
    float metallic  = gbffer1.w;
    vec4 worldPos   = DepthToWorld(uv);

    /////////////////////////////////////////////////////////

    uint reservoirIndex = pixel.y * WINDOW_WIDTH + pixel.x;
	DIReservoir res = RESULT_RESERVOIRS[reservoirIndex];

    vec4 finalColor = vec4(0.0f);
    {
        uint lightID = res.sampl.lightID;

        vec3 pHat = EvaluatePHatFull(
            lightID, worldPos.xyz, normal,
            diffuse, roughness, metallic); 

        finalColor.xyz += pHat * res.w;
    }

    if (RESTIR_DI_SETTING.bruteLighting != 0)  // 暴力遍历光源的测试，算是基线吧
    {
        finalColor = vec4(0.0f);
        for(int i = 0; i < LIGHTS.lightSetting.pointLightCnt; i++)
        {
            uint lightID = LIGHTS.lightSetting.pointLightIDs[i];

            vec3 pHat = EvaluatePHatFull(
            lightID, worldPos.xyz, normal,
            diffuse, roughness, metallic); 

            finalColor.xyz += pHat;
        }
    }

    // 可以把平行光加上
    {
        vec3 N = normalize(normal);
        vec3 V = normalize(CAMERA.pos.xyz - worldPos.xyz);	

        finalColor.xyz +=   DirectionalLighting(diffuse, roughness, metallic, worldPos, N, V) * 
                            RtDirectionalShadow(worldPos, 0.0f);
    }



    if (RESTIR_DI_SETTING.showWeight != 0)
    {
        finalColor = vec4(0.0f);
        if(res.sumWeights > 0.0f) 
            finalColor.xyz += res.w / res.sumWeights;
    }

    if (RESTIR_DI_SETTING.showLightID != 0)
    {
        finalColor = vec4(0.0f);
        finalColor.x += float(res.sampl.lightID) / LIGHTS.lightSetting.pointLightCnt;
    }

    // for (int i = 0; i < RESERVOIR_SIZE; ++i) 
    // {
    //     uint lightID = res.sampl.lightID;
    //     if(lightID == 1) finalColor = vec4(1.0f, 0.0f, 0.0f, 0.0f);
    // }

    imageStore(FINAL_COLOR, pixel, finalColor);
}
