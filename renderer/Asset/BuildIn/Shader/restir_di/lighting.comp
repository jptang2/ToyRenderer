#version 460
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"	
#include "include/common.glsl"	

#define THREAD_SIZE_X 16
#define THREAD_SIZE_Y 16
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main()
{
    ivec2 pixel     = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv         = ScreenPixToUV(pixel); 

    vec4 gbffer0    = imageLoad(G_BUFFER_DIFFUSE_ROUGHNESS, pixel);
    vec4 gbffer1    = imageLoad(G_BUFFER_NORMAL_METALLIC, pixel);
    vec4 gbffer2    = imageLoad(G_BUFFER_EMISSION, pixel);
    vec3 diffuse    = gbffer0.xyz;
    vec3 normal     = gbffer1.xyz;
    vec3 emission   = gbffer2.xyz;
    float roughness = gbffer0.w;
    float metallic  = gbffer1.w;
    vec4 worldPos   = DepthToWorld(uv);

    /////////////////////////////////////////////////////////

    uint reservoirIndex = pixel.y * WINDOW_WIDTH + pixel.x;
	Reservoir res = RESULT_RESERVOIRS[reservoirIndex];

    vec4 finalColor = vec4(0.0f);
    for (int i = 0; i < RESERVOIR_SIZE; ++i) 
    {
        uint lightID = res.samples[i].lightID;

        vec3 pHat = EvaluatePHatFull(
            lightID, worldPos.xyz, normal,
            diffuse, roughness, metallic); 

        finalColor.xyz += pHat * res.samples[i].w;
    }

    if (RESTIR_SETTING.bruteLighting != 0)  // 暴力遍历光源的测试，算是基线吧
    {
        finalColor = vec4(0.0f);
        for(int i = 0; i < LIGHTS.lightSetting.pointLightCnt; i++)
        {
            uint lightID = LIGHTS.lightSetting.pointLightIDs[i];

            vec3 pHat = EvaluatePHatFull(
            lightID, worldPos.xyz, normal,
            diffuse, roughness, metallic); 

            finalColor.xyz += pHat;
        }
    }

    // 可以把平行光加上
    {
        vec3 N = normalize(normal);
        vec3 V = normalize(CAMERA.pos.xyz - worldPos.xyz);	

        finalColor.xyz +=   DirectionalLighting(diffuse, roughness, metallic, worldPos, N, V) * 
                            RtDirectionalShadow(worldPos);
    }



    if (RESTIR_SETTING.showWeight != 0)
    {
        finalColor = vec4(0.0f);
        for (int i = 0; i < RESERVOIR_SIZE; i++) 
        {
            if(res.samples[i].sumWeights > 0.0f) 
                finalColor.xyz += res.samples[i].w / res.samples[i].sumWeights;
        }
    }

    if (RESTIR_SETTING.showLightID != 0)
    {
        finalColor = vec4(0.0f);
        for (int i = 0; i < RESERVOIR_SIZE && i < 4; i++) 
        {
            finalColor[i] += float(res.samples[i].lightID) / LIGHTS.lightSetting.pointLightCnt;
        }
    }

    // for (int i = 0; i < RESERVOIR_SIZE; ++i) 
    // {
    //     uint lightID = res.samples[i].lightID;
    //     if(lightID == 1) finalColor = vec4(1.0f, 0.0f, 0.0f, 0.0f);
    // }

    imageStore(FINAL_COLOR, pixel, finalColor);
}
