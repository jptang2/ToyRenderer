#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"
#include "include/common.glsl"



void RayTraceSurfaceCache(out HitSample hitSample, vec3 worldPos, vec3 worldDir) 
{
	vec4 lighting;
	uint hitObjectID;
    vec4 hitPos;
    vec3 hitNormal;

	bool valid = RayQueryHitObject(
		worldPos, worldPos + normalize(worldDir) * MAX_RAY_TRACING_DISTANCE, 
		hitObjectID, 
		hitPos, 
		hitNormal);

	if(valid)   // 命中物体
	{
		FetchSurfaceCacheLighting(lighting, hitObjectID, hitPos.xyz, hitNormal);

		hitSample.hitPos = hitPos.xyz;
		hitSample.hitNormal = hitNormal;
		hitSample.outRadiance = lighting.xyz;
	}
	else		// 天空盒
	{
		hitSample.hitPos = worldPos + normalize(worldDir) * MAX_RAY_TRACING_DISTANCE;
		hitSample.hitNormal = -worldDir;
		if(RESTIR_GI_SETTING.enableSkybox != 0)	hitSample.outRadiance = FetchSkyLight(worldDir).xyz;
		else									hitSample.outRadiance = vec3(0.0f);
	}
}



#define THREAD_SIZE_X 16
#define THREAD_SIZE_Y 16
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main() 
{
    ivec2 pixel     = ivec2(gl_GlobalInvocationID.xy);
	ivec2 screenPixel = pixel * 2;
    vec2 uv         = ScreenPixToUV(screenPixel); 

    vec4 gbffer0    = imageLoad(G_BUFFER_DIFFUSE_ROUGHNESS, screenPixel);
    vec4 gbffer1    = imageLoad(G_BUFFER_NORMAL_METALLIC, screenPixel);
    vec4 gbffer2    = imageLoad(G_BUFFER_EMISSION, screenPixel);
    vec3 diffuse    = gbffer0.xyz;
    vec3 normal     = normalize(gbffer1.xyz);
    vec3 emission   = gbffer2.xyz;
    float roughness = gbffer0.w;
    float metallic  = gbffer1.w;
    vec4 worldPos   = DepthToWorld(uv);
	float depth 	= FetchDepthTex(screenPixel);

    // 半球方向随机生成采样向量，创建新Reservoir //////////////////////////////////

    uint reservoirIndex = ReservoirIndex(pixel);
    GIReservoir res = NewGIReservoir();
    Rand rand = SeedRand(GLOBAL_SETTING.totalTicks, (pixel.y + WINDOW_HEIGHT / 2) * GLOBAL_SETTING.totalTicks + (pixel.x + WINDOW_WIDTH / 2));

    if(depth == 1.0f)    // 无效的G-Buffer信息
    {
        RESERVOIRS[reservoirIndex] = res;
        return;
    }

	for (int i = 0; i < RESTIR_GI_SETTING.initialSampleCount; i++) 
	{	
		vec4 newSample     = UniformSampleHemisphere(vec2(RandFloat(rand), RandFloat(rand)));     	// 半球均匀采样
		vec3 L             = normalize(TangentToWorld(newSample.xyz, normal));     
		float pdf          = newSample.w;															// proposel PDF, 1 / (2 * PI)

		HitSample hitSample;
		RayTraceSurfaceCache(hitSample, worldPos.xyz, L); 
		float pHat = EvaluatePHat(hitSample); 

		AddSampleToGIReservoir(res, hitSample, pHat, pdf, rand);
	}
	
	// 时域复用Reservoir //////////////////////////////////

	if (RESTIR_GI_SETTING.temporalReuse != 0) 
	{
		vec4 reprojection   = texelFetch(REPROJECTION_RESULT, screenPixel, 0);	
		ivec2 prevPixel     = ivec2(reprojection.zw);
		prevPixel /= 2;
		bool valid          = prevPixel.x > 0.0f ? true : false;	

		if(valid)
		{
			GIReservoir prevRes = PREV_RESERVOIRS[ReservoirIndex(prevPixel)];	
			prevRes.numStreamSamples = min(prevRes.numStreamSamples, RESTIR_GI_SETTING.temporalSampleCountMultiplier * res.numStreamSamples);	// 需要设置一个累计采样数的上限
			
			float newPHat = EvaluatePHat(prevRes.sampl); 
			CombineGIReservoirs(res, prevRes, newPHat, rand);		
		}
	}

	if (RESTIR_GI_SETTING.visibilityReuse != 0) 
	{
		bool shadowed = RayQueryVisibility(worldPos.xyz, res.sampl.hitPos);
		if (shadowed) 
		{
			CleanGIReservoir(res);		
		}
	}

	RESERVOIRS[reservoirIndex] = res;
	// RESULT_RESERVOIRS[reservoirIndex] = res;
}
