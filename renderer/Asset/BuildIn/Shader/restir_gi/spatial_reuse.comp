#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"
#include "include/common.glsl"




float CalculateJacobian(
    vec3 receiverPos,
    vec3 neighborreceiverPos,
    in HitSample neighborSample)
{
    vec3 sampleToNeighborReceiver =
        neighborreceiverPos - neighborSample.hitPos;

    float originalDistance = length(sampleToNeighborReceiver);
    float originalCosAngle = saturate(dot(
        neighborSample.hitNormal,
        sampleToNeighborReceiver / originalDistance));
    vec3 sampleToReceiver = receiverPos - neighborSample.hitPos;
    float newDistance =length(sampleToReceiver);
    float newCosAngle = saturate(dot(neighborSample.hitNormal, sampleToReceiver / newDistance));    

    float jacobian =
        (newCosAngle *originalDistance * originalDistance)/
        (originalCosAngle *newDistance *newDistance);
    if(isinf(jacobian)|| isnan(jacobian))
        jacobian = 0;

    // TraceHitNormal is 0 when the ray misses the scene
    if(abs(dot(neighborSample.hitNormal, vec3(1.0f))) < 0.01f)
        jacobian = 1.0f;
    // Discard extreme re-weights that show up as fireflies
    if(jacobian > 10.0f || jacobian < 0.1f)
        jacobian = 0.0f;

    return jacobian;
}











#define THREAD_SIZE_X 16
#define THREAD_SIZE_Y 16
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main() 
{
    ivec2 pixel     = ivec2(gl_GlobalInvocationID.xy);
	ivec2 screenPixel = pixel * 2;
    vec2 uv         = ScreenPixToUV(screenPixel); 

   	vec4 gbffer0    = imageLoad(G_BUFFER_DIFFUSE_ROUGHNESS, screenPixel);
    vec4 gbffer1    = imageLoad(G_BUFFER_NORMAL_METALLIC, screenPixel);
    vec4 gbffer2    = imageLoad(G_BUFFER_EMISSION, screenPixel);
    vec3 diffuse    = gbffer0.xyz;
    vec3 normal     = normalize(gbffer1.xyz);
    vec3 emission   = gbffer2.xyz;
    float roughness = gbffer0.w;
    float metallic  = gbffer1.w;
    vec4 worldPos   = DepthToWorld(uv); 
	float depth 	= FetchDepthTex(screenPixel);

	// 空域复用Reservoir //////////////////////////////////

	uint reservoirIndex = ReservoirIndex(pixel);
	GIReservoir res = RESERVOIRS[reservoirIndex];
	Rand rand = SeedRand(GLOBAL_SETTING.totalTicks, pixel.y * GLOBAL_SETTING.totalTicks + pixel.x);

	vec3 neighborNormal[NUM_NEIGHBORS];
    vec4 neighborWorldPos[NUM_NEIGHBORS];
	uint neighborNumStreamSamples[NUM_NEIGHBORS];
	uint originNumStreamSamples = res.numStreamSamples;

	if(depth < 1.0f && RESTIR_GI_SETTING.spatialReuse != 0)
	{
		for(int j = 0; j < NUM_NEIGHBORS; j++)
		{	
			float angle = RandFloat(rand) * 2.0 * PI;								// 搜索圆范围内的随机临近像素
			float radius = sqrt(RandFloat(rand)) * RESTIR_GI_SETTING.spatialRadius;

			ivec2 randNeighborOffset = ivec2(floor(cos(angle) * radius), floor(sin(angle) * radius));
			ivec2 randNeighborPixel  = ivec2(clamp(int(pixel.x) + randNeighborOffset.x, 0, int(WINDOW_WIDTH) / 2 - 1),
											 clamp(int(pixel.y) + randNeighborOffset.y, 0, int(WINDOW_HEIGHT) / 2 - 1));
            ivec2 randNeighborScreenPixel = randNeighborPixel * 2;
			vec2 randNeighborUV = ScreenPixToUV(randNeighborScreenPixel);
			uint randIndex 		= ReservoirIndex(randNeighborPixel);	
			
			neighborNumStreamSamples[j] = RESERVOIRS[randIndex].numStreamSamples; 
			neighborNormal[j] = normalize(imageLoad(G_BUFFER_NORMAL_METALLIC, randNeighborScreenPixel).xyz);
            neighborWorldPos[j] = DepthToWorld(randNeighborUV); 

			float neighborDepth = FetchDepthTex(randNeighborScreenPixel);
			if(neighborDepth == 1.0f) 
			{
				neighborNumStreamSamples[j] = 0;
				continue;
			}

			// 几何相似性检测
			{
				vec3 positionDiff = worldPos.xyz - neighborWorldPos[j].xyz;
				float normalDot = dot(normal, neighborNormal[j]);
				if (length(positionDiff) > RESTIR_GI_SETTING.spatialPosThreshold  ||        // 弃置世界距离差异大的，原论文比较的是深度
					normalDot < cos(radians(RESTIR_GI_SETTING.spatialNormalThreshold)))		// 弃置法线差异大的
				{
					neighborNumStreamSamples[j] = 0;
					continue;
				}
			}

			GIReservoir randRes = RESERVOIRS[randIndex];
			float newPHat = EvaluatePHat(randRes.sampl) * CalculateJacobian(worldPos.xyz, neighborWorldPos[j].xyz, randRes.sampl); 
			CombineGIReservoirs(res, randRes, newPHat, rand);  
		}

		if(RESTIR_GI_SETTING.unbias != 0)
		{
            uint z = originNumStreamSamples;
            for(int j = 0; j < NUM_NEIGHBORS; j++)
            {		
                if(RESTIR_GI_SETTING.visibilityReuse != 0)		// 可见性测试是最主要的性能开销
                {
                    bool shadowed = RayQueryVisibility(neighborWorldPos[j].xyz, res.sampl.hitPos);
                    if(shadowed) continue;
                }
                        
                z = z + neighborNumStreamSamples[j]; 				
            }

            if(RESTIR_GI_SETTING.visibilityReuse != 0)
            {
                bool shadowed = RayQueryVisibility(worldPos.xyz, res.sampl.hitPos);
                if(shadowed) 
                {
                    CleanGIReservoir(res);			
                }
            }
            
            if (z > 0 && res.pHat > 0.0) 
            {
                res.w = (1.0 / res.pHat) * (1.0 / z) * res.sumWeights;	// 无偏就是这两行的区别
                //res.w = (1.0 / res.pHat) * (1.0 / res.numStreamSamples) * res.sumWeights;	
                // 由于错误的考虑了pHat为0的采样，有偏的实际上会偏暗
            }
            else {
                CleanGIReservoir(res);			
            }
		}
	}

	RESULT_RESERVOIRS[reservoirIndex] = res;
}
