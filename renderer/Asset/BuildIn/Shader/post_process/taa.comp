#version 460
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"

layout(set = 1, binding = 0) uniform texture2D CURRENT_COLOR;
layout(set = 1, binding = 1) uniform texture2D HISTORY_COLOR;
layout(set = 1, binding = 2) uniform texture2D REPROJECTION_RESULT;	
layout(set = 1, binding = 3, rgba16f) uniform image2D OUT_COLOR;

layout(push_constant) uniform TAASetting 
{
    int enable;
    int sharpen;
    int reprojectionOnly;
    int showVelocity;
    float velocityFactor;
    float blendFactor;
    
} SETTING;

// vec3 find_closest_fragment_3x3(vec2 uv, vec2 texSize, sampler2D depth)
// {
//     vec2 dd = abs(texSize.xy);
//     vec2 du = vec2(dd.x, 0.0);
//     vec2 dv = vec2(0.0, dd.y);

//     vec3 dtl = vec3(-1, -1, texture(depth, uv - dv - du).x);
//     vec3 dtc = vec3(0, -1, texture(depth, uv - dv).x);
//     vec3 dtr = vec3(1, -1, texture(depth, uv - dv + du).x);

//     vec3 dml = vec3(-1, 0, texture(depth, uv - du).x);
//     vec3 dmc = vec3(0, 0, texture(depth, uv).x);
//     vec3 dmr = vec3(1, 0, texture(depth, uv + du).x);

//     vec3 dbl = vec3(-1, 1, texture(depth, uv + dv - du).x);
//     vec3 dbc = vec3(0, 1, texture(depth, uv + dv).x);
//     vec3 dbr = vec3(1, 1, texture(depth, uv + dv + du).x);

//     vec3 dmin = dtl;
//     if (dmin.z > dtc.z) dmin = dtc;
//     if (dmin.z > dtr.z) dmin = dtr;

//     if (dmin.z > dml.z) dmin = dml;
//     if (dmin.z > dmc.z) dmin = dmc;
//     if (dmin.z > dmr.z) dmin = dmr;

//     if (dmin.z > dbl.z) dmin = dbl;
//     if (dmin.z > dbc.z) dmin = dbc;
//     if (dmin.z > dbr.z) dmin = dbr;

//     return vec3(uv + dd.xy * dmin.xy, dmin.z);
// }


#define THREAD_SIZE_X 16
#define THREAD_SIZE_Y 16
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main() 
{	
    ivec2 pixel     = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv         = ScreenPixToUV(pixel); 

    float blend     = SETTING.blendFactor;

    vec4 reprojection   = texelFetch(REPROJECTION_RESULT, pixel, 0);
    vec2 prevUV         = reprojection.xy;
    bool valid          = prevUV.x > 0.0f ? true : false;

    //重投影
    // if(SETTING.reprojectionOnly > 0)
    // {
    //     vec3 worldPos       = DepthToWorld(uv).xyz;                                             //本帧的世界空间坐标（假定物体不动，也就是前一帧的）
    //     vec4 prevClipPos    = CAMERA.prevProj * CAMERA.prevView * vec4(worldPos, 1.0f);         //前帧的裁剪空间坐标
    //     prevUV              = (prevClipPos.xy / prevClipPos.w) * 0.5 + vec2(0.5);               //前帧的UV
    //     valid 			    = any(lessThan(prevUV, vec2(0.0f))) || any(greaterThan(prevUV, vec2(1.0f))) ? false : true;

    //     // float prevDepth     = Linear01Depth(prevClipPos.z / prevClipPos.w, CAMERA.near_far[0], CAMERA.near_far[1]);
    //     // float currDepth     = Linear01Depth(fetchDepth(uv), CAMERA.near_far[0], CAMERA.near_far[1]);
    //     // float deltaDepth    = abs(prevDepth - currDepth);
    // }

    if(!valid)  blend = 1.0f;

    AdjacentTex3 currentAdj     = TextureAdj3(CURRENT_COLOR, pixel);
    vec3 currColor              = currentAdj.color[1][1];
    RGBtoYCoCg(currentAdj);

    vec3 historyColor           = RGBtoYCoCg(texture(sampler2D(HISTORY_COLOR, SAMPLER[0]), prevUV).xyz);
    historyColor                = YCoCgtoRGB(ClampedColor(historyColor, currentAdj));

    //锐化
    if (SETTING.enable > 0 &&
        SETTING.sharpen > 0)
    {
        vec3 sum = vec3(0.0);

        sum += -1.0 *   currentAdj.color[0][1];
        sum += -1.0 *   currentAdj.color[1][0];
        sum += 5.0 *    currentAdj.color[1][1];
        sum += -1.0 *   currentAdj.color[1][2];
        sum += -1.0 *   currentAdj.color[2][1];

        currColor = max(YCoCgtoRGB(sum), vec3(0.0f));
    }

    //色调映射
    historyColor        = ToneMap(max(historyColor, 0.0f));
    currColor           = ToneMap(max(currColor, 0.0f));

    vec3 finalColor     = Lerp(historyColor, currColor, blend);
    finalColor          = InverseToneMap(finalColor);
    currColor           = InverseToneMap(currColor);
    historyColor        = InverseToneMap(historyColor);

    vec4 outColor = vec4(0.0f);
    if(SETTING.enable > 0)
    {
        outColor.xyz       = finalColor;
        outColor.a         = 1.0f;
    }
    else
    {
        outColor.xyz       = currColor;
        outColor.a         = 1.0f;
    }

    if(SETTING.showVelocity > 0)
    {
        outColor.rg       = FetchVelocityTex(pixel) * SETTING.velocityFactor;
        outColor.ba       = vec2(0.0f, 1.0f);
    }

    if(SETTING.reprojectionOnly > 0)
    {
        ivec2 prevPixel = ivec2(reprojection.zw);
        bool pixelValid = prevPixel.x > 0.0f ? true : false;

        if(SETTING.sharpen > 0) // clamp之后的结果
        {
            if(valid)       outColor = vec4(historyColor, 1.0f);     
            //if(pixelValid)  outColor = vec4(historyColor, 1.0f);     
            else            outColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
        }
        else {                  // 无clamp结果
            vec3 reprojectionColor   = texture(sampler2D(HISTORY_COLOR, SAMPLER[0]), prevUV).xyz;
            if(valid)       outColor = vec4(reprojectionColor, 1.0f);   
            //vec3 reprojectionColor   = texelFetch(HISTORY_COLOR, prevPixel, 0).xyz;
            //if(pixelValid)  outColor = vec4(reprojectionColor, 1.0f);   
            else            outColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);
        }
    }

    imageStore(OUT_COLOR, pixel, outColor);
}

