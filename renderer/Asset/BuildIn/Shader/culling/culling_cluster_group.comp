#version 460
#extension GL_GOOGLE_include_directive : enable

#include "../common/common.glsl"
#include "common.glsl"

#define THREAD_SIZE_X 64
#define THREAD_SIZE_Y 1
#define THREAD_SIZE_Z 1
layout (local_size_x = THREAD_SIZE_X, 
		local_size_y = THREAD_SIZE_Y, 
		local_size_z = THREAD_SIZE_Z) in;
void main() 
{
	uint gID = gl_GlobalInvocationID.x;

	// 逐cluster group剔除		// 各个pass的cluster选择是完全一样的，都是根据屏幕空间error，下面的循环可以直接改掉
	if(gID < CLUSTER_GROUP_DRAW_DATAS[0].setting.processSize)
	{
		IndirectClusterGroupDrawInfo groupInfo = CLUSTER_GROUP_DRAW_DATAS[0].draws[gID];

		MeshClusterGroup group = MESH_CLUSTER_GROUPS.slot[groupInfo.clusterGroupID];
		Object object = OBJECTS.slot[groupInfo.objectID];

		if(SETTING.disableVirtualMeshCulling != 0)
		{
			if(group.mipLevel == 0)	// 跳过group剔除，则只选择LOD0
			{
				for(uint j = 0; j < group.clusterSize; j++)
				{
					MeshCluster cluster = MESH_CLUSTERS.slot[group.clusterID[j]];

					IndirectClusterDrawInfo clusterInfo;								//把cluster的信息填进缓冲里，在下面里进一步做剔除
					clusterInfo.objectID = groupInfo.objectID;
					clusterInfo.clusterID = group.clusterID[j];
					clusterInfo.commandID = groupInfo.commandID;

					for(int passIndex = 0; passIndex < SETTING.passCount; passIndex++)
					{
						uint offset = atomicAdd(CLUSTER_DRAW_DATAS[passIndex].setting.processSize, 1);	
						CLUSTER_DRAW_DATAS[passIndex].draws[offset] = clusterInfo;

						if(SETTING.enableStatistics != 0)
							atomicAdd(CLUSTER_GROUP_DRAW_DATAS[passIndex].setting.drawSize, 1);		
					}
				}
			}
		}
		else 
		{
			//BoundingSphere viewGroupSphere = SphereTransform(group.sphere, CAMERA.view * object.model, object.localScale.xyz * object.modelScale.xyz);	
			BoundingSphere viewObjectSphere = SphereTransform(object.sphere, CAMERA.view * object.model, object.localScale.xyz * object.modelScale.xyz);		//统一使用object的包围盒做距离测试，保证计算的误差一致

			//if(group.mipLevel == 0)
			if(!CheckLOD(viewObjectSphere, group.parentLodError))	//父节点error应该大于阈值		
			{
				for(uint j = 0; j < group.clusterSize; j++)
				{
					MeshCluster cluster = MESH_CLUSTERS.slot[group.clusterID[j]];

					//BoundingSphere view_cluster_sphere = SphereTransform(cluster.sphere, CAMERA.view * object.model, object.localScale.xyz * object.modelScale.xyz);	
					if(CheckLOD(viewObjectSphere, cluster.lodError))						//cluster本身error小于阈值
					{
						IndirectClusterDrawInfo clusterInfo;								//把cluster的信息填进缓冲里，在下面里进一步做剔除
						clusterInfo.objectID = groupInfo.objectID;
						clusterInfo.clusterID = group.clusterID[j];
						clusterInfo.commandID = groupInfo.commandID;

						for(int passIndex = 0; passIndex < SETTING.passCount; passIndex++)
						{
							uint offset = atomicAdd(CLUSTER_DRAW_DATAS[passIndex].setting.processSize, 1);	
							CLUSTER_DRAW_DATAS[passIndex].draws[offset] = clusterInfo;

							if(SETTING.enableStatistics != 0)
								atomicAdd(CLUSTER_GROUP_DRAW_DATAS[passIndex].setting.drawSize, 1);		
						}
					}
				}
			}
		}
	}

	// 逐cluster剔除放在下一个pass里，atomicAdd好像对线程读写是局部的？
}



